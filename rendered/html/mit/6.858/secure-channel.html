<!DOCTYPE html><html><head>
      <title>temporary</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script
  src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/js/all.min.js"
  crossorigin="anonymous"
></script>
<style>
body {
  font-family: 'Open Sans', sans-serif;
  width: 100%;
  height: 100%;
  top: 0;
  margin: 0;
  padding: 2em calc(max(50% - 457px + 2em, 1em));
  position: relative;
  font-size: 16px;
  line-height: 1.6;
  background-color: #fff;
  overflow: initial;
  box-sizing: border-box;
  word-wrap: break-word;
  color: black;
  background-color: white;
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
}
body > :first-child {
  margin-top: 0;
}
body h1,
body h2,
body h3,
body h4,
body h5,
body h6 {
  color: black;
  padding-bottom: 8px;
  border-bottom: 1px solid black;
  font-weight: 600;
  margin-top: 1em;
  margin-bottom: 16px;
  line-height: 1.2;
}
body h1 {
  font-size: 2.25em;
  padding-bottom: 0.3em;
}
body h2 {
  font-size: 1.75em;
  padding-bottom: 0.3em;
}
body h3 {
  font-size: 1.5em;
}
body h4 {
  font-size: 1.25em;
}
body h5 {
  font-size: 1.1em;
}
body h6 {
  font-size: 1em;
}
body p + ul {
  margin-top: -15px;
}
body a:not([href]) {
  color: inherit;
  text-decoration: none;
}
body a {
  color: #08c;
  text-decoration: none;
}
body a:hover {
  color: #00a3f5;
  text-decoration: none;
}
body > p {
  margin-top: 0;
  margin-bottom: 16px;
  word-wrap: break-word;
}
body > ol,
body > ul {
  margin-bottom: 16px;
}
body ol,
body ul {
  padding-left: 2em;
}
body ol ol,
body ol ul,
body ul ol,
body ul ul {
  margin-top: 0;
  margin-bottom: 0;
}
body li {
  margin-bottom: 0;
}
body li > p {
  margin-top: 0;
  margin-bottom: 0;
}
body code {
  font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
  font-size: 1em;
  padding: 0.15em 0.25em;
  margin: 0;
  white-space: break-spaces;
  background-color: #afb8c133;
  border-radius: 6px;
  color: #000000;
}
body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  color: #1f2328;
  background-color: #e3e6e9;
  border-radius: 6px;
}
body pre > code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}
body hr {
  height: 1px;
  margin: 8px 0;
  background-color: #000000;
  border: 0 none;
}
body table {
  margin: 10px 0 15px 0;
  border-collapse: collapse;
  border-spacing: 0;
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}
body table th {
  font-weight: 700;
  color: #000;
}
body table td,
body table th {
  border: 1px solid #d6d6d6;
  padding: 6px 13px;
}
body dl {
  padding: 0;
}
body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 700;
}
body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}
body ul {
  list-style: disc;
}
body ul ul {
  list-style: circle;
}
body ul ul ul {
  list-style: square;
}
body own-preview ol {
  list-style: decimal;
}
body own-preview ol ol,
body ul ol {
  list-style-type: lower-roman;
}
body own-preview ol ol ol,
body own-preview ol ul ol,
body ul ol ol,
body ul ul ol {
  list-style-type: lower-alpha;
}
body img {
  width: 100%;
  display: block;
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 25px;
}
body .image-caption {
  font-size: 0.8em;
  color: #494949;
  text-align: center;
  margin: -20px auto 10px;
  width: 100%;
}
body .definition {
  border-color: #06c406;
}
body .definition .title {
  background-color: #d9ffd9;
}
body .info {
  border-color: #448aff;
}
body .info .title {
  background-color: #ecf3ff;
}
body .proposition {
  border-color: #448aff;
}
body .proposition .title {
  background-color: #ecf3ff;
}
.admonition {
  border: 1px solid;
  border-radius: 8px;
  margin-bottom: 10px;
}
.admonition .title {
  font-size: 1.125em;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 8px 8px 0px 0px;
}
.admonition .title svg {
  margin-right: 4px;
}
.admonition .title p {
  margin: 0px;
}
.admonition .body {
  padding: 8px 10px 0px;
}
.admonition .body > :first-child {
  margin-top: 0;
}
.admonition .body > :last-child {
  margin-bottom: 4px;
}
</style>
</head>
<body><h2>Secure Channel</h2>
<ul>
<li>TCP / IP by itself doesn&#39;t provide authenticity / confidentiality</li>
<li>Need cryptography to layer a secure channel on top of it<ul>
<li>TLS / SSL</li>
</ul>
</li>
</ul>
<h3>Public Key Operations</h3>
<ul>
<li><code>KeyGen()</code>: generates public key <code>PK</code> and secret key <code>SK</code></li>
<li><code>Encrypt(PK, msg m)</code>: generates ciphertext <code>c</code></li>
<li><code>Decrypt(SK, c)</code>: gives back <code>m</code></li>
<li><code>Sign(SK, msg m)</code>: generates signature <code>sig</code></li>
<li><code>Verify(PK, m, sig)</code>: is signature valid?</li>
</ul>
<h3>Private / Symmetric Key Operations</h3>
<ul>
<li><code>KeyGen()</code>: generates private / symmetric key <code>K</code></li>
<li><code>Encrypt(K, m)</code> generates <code>c</code></li>
<li><code>Decrypt(K, c)</code> generates <code>m</code></li>
<li><code>MAC(K, m)</code> generates a tag <code>t</code><ul>
<li>Should use diff key from encryption</li>
</ul>
</li>
<li>Very fast, but key has to be a shared secret</li>
</ul>
<h3>DH Key Exchange</h3>
<ul>
<li>If you have <code>PK_A, SK_A, PK_B, SK_B</code> there is a way to combine <code>PK</code> and <code>SK</code> such that:<ul>
<li><code>shared = DH(PK_A, SK_B) = DH(PK_B, SK_A)</code></li>
</ul>
</li>
<li>Useful for computing shared secrets without having to send them over the wire!</li>
</ul>
<h3>Strawman 1:</h3>
<pre><code>C --&gt; S: connection request
C &lt;-- S: client receives server&#39;s public key PK_S
C --&gt; S: client sends a new key to server to use in their communication
C &lt;-&gt; S:
</code></pre>
<p>Problem: authenticating the server</p>
<ul>
<li>What if an adversary intercepts messages to the server?</li>
<li>The client then has a shared key with the adversary</li>
<li>The adversary can connect to the real server and relay messages</li>
<li>&quot;Man in the middle&quot; attack</li>
<li>Idea: need to bind PK_S to server&#39;s identity</li>
</ul>
<h3>Certificates</h3>
<p>Solution: trusted authority server</p>
<ul>
<li>Maintains table of (principal name, public key) pairs<ul>
<li>Principal name is typically the server&#39;s DNS name</li>
<li>Choice of name must capture the client&#39;s intended communication target</li>
<li>Crucial that it is correct</li>
</ul>
</li>
<li>Everyone needs to know the trusted authority server&#39;s public key</li>
<li>Each person could query the server, but that&#39;s bad for availability / performance<ul>
<li>Authority server can instead sign a message: <code>Sign(SK_CA, {server, PK_server})</code></li>
<li>This is the &quot;certificate&quot;</li>
<li>Clients can verify it is correctly signed by the certificate authority because they all have the CA&#39;s public key</li>
</ul>
</li>
</ul>
<h3>Revised Protocol</h3>
<pre><code>C --&gt; S: connection request
C &lt;-- S: PK_S and server&#39;s certificate (Sign(SK_CA, { server, PK_server})
C --&gt; S: encrypted fresh key
C &lt;-&gt; S: communication with fresh key
</code></pre>
<p>Alternative:</p>
<ul>
<li>Trust-on-first use:<ul>
<li>Assume first connection is OK</li>
<li>Remember binding between PK_S and server&#39;s name for future use</li>
</ul>
</li>
</ul>
<p>Problem: authenticating the messages</p>
<ul>
<li><p>When a client sends a message, an adversary can modify it</p>
</li>
<li><p>Decrypt always succeeds, so adversary can tamper with ciphertext</p>
</li>
<li><p>This can sometimes have predictable effects (i.e. changing a bit flips a bit in message)</p>
</li>
<li><p>Solution: use MAC to compute an authentication tag</p>
<ul>
<li>Use two keys: one for encrypting and one for MAC</li>
<li>When you send ciphertext, also send the <code>t = MAC(MAC_KEY, c)</code></li>
<li>If the tag is incorrect, something was modified</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>New problem: replay attacks<ul>
<li>Two common solutions:</li>
<li>Sequence number in message<ul>
<li>Receiver tracks last-seen SN and discards messages with older ones</li>
<li>Good for stream oriented protocols</li>
</ul>
</li>
<li>Expiration / session ID in message<ul>
<li>Receiver tracks all past messages sent within expiration time / session</li>
<li>Checks to see if any have been previously received</li>
<li>Good for message-oriented protocols</li>
</ul>
</li>
</ul>
</li>
<li>Another problem: server breakins<ul>
<li>What if a bad guy later compromises the server?</li>
<li>Can use SK_S to decrypt old network traffic<ul>
<li>Even if you use a fresh key for every communication, you sent that across the stream at some point</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Forward Secrecy</h3>
<ul>
<li>Solution: don&#39;t use long-term keys for encryption<ul>
<li>Subsceptible to decryption by a future adversary</li>
</ul>
</li>
<li>Add a long-term signing key</li>
<li>Use short-lived keys for encryption and long-term keys for signing<ul>
<li>Future adversary can forge signatures in the future, but it&#39;s too late at that point</li>
</ul>
</li>
<li>New protocol:<ul>
<li>Both C and S generate connection key pairs taht will be combined with DH</li>
</ul>
</li>
</ul>
<pre><code>C --&gt; S: connection request with PK_conn_C
C &lt;-- S: PK_conn_S, Sign(SK_CA, {server: PK_S}), Sign(SK_S, PK_conn_S)

Both can then compute PK_conn

C --&gt; S: Encrypt(PK_conn, freshKey)
C &lt;-&gt; S: Encrypt(freshKey, m)
</code></pre>
<ul>
<li>The SK_conn and PK_conn are only used once to get the fresh key and then are thrown away</li>
</ul>
<h2>SSL / TLS</h2>
<ul>
<li>Secure channel protocol for the web</li>
<li>TLS is the international standard version of SSL</li>
<li>Main parts:<ul>
<li>Record protocol</li>
<li>Handshake protocol</li>
</ul>
</li>
<li>Threat model:<ul>
<li>Active attackers that tamper and forge messages</li>
<li>Passive attackers that eavesdrop</li>
</ul>
</li>
<li>SSL 2.0, SSL 3.0 (1996), TLS 1.0 (1999), TLS 1.1 (2006), TLS 1.2 (2008), TLS 1.3 (2018)</li>
</ul>
<hr>
<ul>
<li>Issue that complicates TLS: figuring out what encryption scheme to use<ul>
<li>Cipher negotiation (how the shared secret will be used)</li>
<li>Key exchange (DH, figuring out how to combine the keys)</li>
<li>Signing (how to compute these MAC things)</li>
</ul>
</li>
<li>Big problem with TLS: reducing round trips</li>
</ul>
<p>Naive version (+2 RTT (round trip time), TLS 1.2):</p>
<pre><code>C --&gt; S: hello with all supported encryption schemes
S --&gt; C: tells the client what to use

Then we spend a round trip doing above to actually get the shared secret
</code></pre>
<p>TLS1.3: client guesses the key exchange algorithm when sending the first message to include PK_conn_C</p>
<ul>
<li>If correct, server can immediately send back PK_conn_S</li>
<li>Web browsers can remember which servers use which schemes</li>
<li>Almost everyone just uses X25519 as the default and it just works</li>
</ul>
<p>0 RTT: just making the guess correct is not enough to get 0 RTT because you still need the server to send back its public key</p>
<ul>
<li>CANNOT achieve forward secrecy</li>
<li>But you can turn on this mode if you have already talked to the server before and remember which K to use</li>
<li>Ways of implementing this:<ul>
<li>Server stores sessions and keys used for those sessions<ul>
<li>Client just has to send the session ID and the server remembers</li>
<li>Server has to store state</li>
</ul>
</li>
<li>Stateless version: server can store a K_ticket globally and whenever the server and client have a communication, it encrypts the key with K_ticket and gives it back to the client<ul>
<li>The client just has to present this ticket again and the server can remember what key to use</li>
</ul>
</li>
</ul>
</li>
<li>Subsceptible to replay attacks because we are reusing these keys and not generating fresh ones</li>
</ul>
<h3>Downgrading Attack</h3>
<ul>
<li>Adversaries can modify the hello messages (since they aren&#39;t signed) and force the parties to use a weaker cipher, which might have been discovered to have vulnerabilities</li>
<li>TLS 1.3 solves this by when the signature is sent back, we sign the entire transcript of the conversation we have been having</li>
</ul>
<h2>E2E</h2>
<ul>
<li>Compromised server can still access data if the server has decryption<ul>
<li>Alternative: do not give server the decryption key</li>
</ul>
</li>
<li>Data encrypted with key of intended recipient<ul>
<li>Not necessarily server that transmits / stores message</li>
<li>Server stores / forwards ciphertext</li>
</ul>
</li>
<li>How to deal with shared encrypted data (i.e. multiple users have access to shared doc)<ul>
<li>Naive plan: encrypt same document with each user&#39;s key</li>
<li>Downside: multiple copies that are potentially divergent</li>
<li>Better plan: chain keys<ul>
<li>Generate a new key just for the document</li>
<li>Encrypt document with the document&#39;s public key</li>
<li>Encrypt document&#39;s secret key with each user&#39;s public key</li>
</ul>
</li>
</ul>
</li>
</ul>
</body></html>