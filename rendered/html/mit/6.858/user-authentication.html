<!DOCTYPE html><html><head>
      <title>temporary</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script
  src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/js/all.min.js"
  crossorigin="anonymous"
></script>
<style>
body {
  font-family: 'Open Sans', sans-serif;
  width: 100%;
  height: 100%;
  top: 0;
  margin: 0;
  padding: 2em calc(max(50% - 457px + 2em, 1em));
  position: relative;
  font-size: 16px;
  line-height: 1.6;
  background-color: #fff;
  overflow: initial;
  box-sizing: border-box;
  word-wrap: break-word;
  color: black;
  background-color: white;
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
}
body > :first-child {
  margin-top: 0;
}
body h1,
body h2,
body h3,
body h4,
body h5,
body h6 {
  color: black;
  padding-bottom: 8px;
  border-bottom: 1px solid black;
  font-weight: 600;
  margin-top: 1em;
  margin-bottom: 16px;
  line-height: 1.2;
}
body h1 {
  font-size: 2.25em;
  padding-bottom: 0.3em;
}
body h2 {
  font-size: 1.75em;
  padding-bottom: 0.3em;
}
body h3 {
  font-size: 1.5em;
}
body h4 {
  font-size: 1.25em;
}
body h5 {
  font-size: 1.1em;
}
body h6 {
  font-size: 1em;
}
body p + ul {
  margin-top: -15px;
}
body a:not([href]) {
  color: inherit;
  text-decoration: none;
}
body a {
  color: #08c;
  text-decoration: none;
}
body a:hover {
  color: #00a3f5;
  text-decoration: none;
}
body > p {
  margin-top: 0;
  margin-bottom: 16px;
  word-wrap: break-word;
}
body > ol,
body > ul {
  margin-bottom: 16px;
}
body ol,
body ul {
  padding-left: 2em;
}
body ol ol,
body ol ul,
body ul ol,
body ul ul {
  margin-top: 0;
  margin-bottom: 0;
}
body li {
  margin-bottom: 0;
}
body li > p {
  margin-top: 0;
  margin-bottom: 0;
}
body code {
  font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
  font-size: 1em;
  padding: 0.15em 0.25em;
  margin: 0;
  white-space: break-spaces;
  background-color: #afb8c133;
  border-radius: 6px;
  color: #000000;
}
body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  color: #1f2328;
  background-color: #e3e6e9;
  border-radius: 6px;
}
body pre > code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}
body hr {
  height: 1px;
  margin: 8px 0;
  background-color: #000000;
  border: 0 none;
}
body table {
  margin: 10px 0 15px 0;
  border-collapse: collapse;
  border-spacing: 0;
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}
body table th {
  font-weight: 700;
  color: #000;
}
body table td,
body table th {
  border: 1px solid #d6d6d6;
  padding: 6px 13px;
}
body dl {
  padding: 0;
}
body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 700;
}
body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}
body ul {
  list-style: disc;
}
body ul ul {
  list-style: circle;
}
body ul ul ul {
  list-style: square;
}
body own-preview ol {
  list-style: decimal;
}
body own-preview ol ol,
body ul ol {
  list-style-type: lower-roman;
}
body own-preview ol ol ol,
body own-preview ol ul ol,
body ul ol ol,
body ul ul ol {
  list-style-type: lower-alpha;
}
body img {
  width: 100%;
  display: block;
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 25px;
}
body .image-caption {
  font-size: 0.8em;
  color: #494949;
  text-align: center;
  margin: -20px auto 10px;
  width: 100%;
}
body .definition {
  border-color: #06c406;
}
body .definition .title {
  background-color: #d9ffd9;
}
body .info {
  border-color: #448aff;
}
body .info .title {
  background-color: #ecf3ff;
}
body .proposition {
  border-color: #448aff;
}
body .proposition .title {
  background-color: #ecf3ff;
}
.admonition {
  border: 1px solid;
  border-radius: 8px;
  margin-bottom: 10px;
}
.admonition .title {
  font-size: 1.125em;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 8px 8px 0px 0px;
}
.admonition .title svg {
  margin-right: 4px;
}
.admonition .title p {
  margin: 0px;
}
.admonition .body {
  padding: 8px 10px 0px;
}
.admonition .body > :first-child {
  margin-top: 0;
}
.admonition .body > :last-child {
  margin-bottom: 4px;
}
</style>
</head>
<body><h2>User Authentication</h2>
<ul>
<li>Continues to be challenging because security isn&#39;t just technical<ul>
<li>Users pick bad passwords</li>
</ul>
</li>
<li>Model:<ul>
<li>Client sends request to server</li>
<li>How does the server check each request for authentication?</li>
<li>How do they implement a <strong>guard</strong></li>
</ul>
</li>
<li>Three parts:<ul>
<li>Registration: set up secret</li>
<li>Authentication: check user sent secret to ensure it matches with copy</li>
<li><strong>Recovery</strong>: what happens if user loses secret</li>
</ul>
</li>
<li>Principal = user that wants to be authenticated</li>
<li>Challenge: intermediaries<ul>
<li>The request from the user goes through many intermediaries</li>
<li>Final server just receives a TCP packet</li>
<li>Need to consider the possibility that the request isn&#39;t actually from the user<ul>
<li>I.e. attacker controls load balancer / user device / etc.</li>
</ul>
</li>
</ul>
</li>
<li>Challenge: verifying user&#39;s identity on registration<ul>
<li>How do we know the person who registered is actually who they say they are?</li>
<li>Some companies don&#39;t care (i.e. Amazon) as long as you just pay</li>
</ul>
</li>
</ul>
<h3>Registration</h3>
<ul>
<li>Approaches:<ul>
<li>First-come first-serve:<ul>
<li>Register for an account at gmail.com</li>
</ul>
</li>
<li>Bootstrap from another mechanism (i.e. email)</li>
<li>Created by administrator<ul>
<li>I.e. for new employees</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Recovery</h3>
<ul>
<li>Approaches:<ul>
<li>Security questions</li>
<li>Verify via email</li>
<li>Prove knowledge of credit card number</li>
<li>Create new account</li>
<li>Call customer service (subsceptible to social engineering)</li>
</ul>
</li>
</ul>
<h2>Passwords</h2>
<ul>
<li>Commonly used as a secret</li>
<li>Principal and guard share a secret set of bits</li>
<li>Easy to use and deploy, but often very weak<ul>
<li>Use them as little as possible (just for user authentication)</li>
<li>Once a user is authenticated, use crypto keys between server / clients</li>
<li>Even for user authentication, can combine with other ideas such as password manager; single-sign on, two-factor, etc.</li>
</ul>
</li>
<li>Problems with apsswords:<ul>
<li>Users choose guessable passwords<ul>
<li>20% of accounts use the same set of 5,000 most popular passwords</li>
</ul>
</li>
<li>Common passwords contain digits / upper case / lower case<ul>
<li>What matters is entropy: 1 bit of entropy = password would be guessed on the first attempt half the time</li>
<li>Password of 16 bits of entropy requires 2^16 guesses to try all possibilities</li>
</ul>
</li>
<li>Passwords often shared across sites / apps</li>
<li>Want to encourage users to choose high-entropy passwords<ul>
<li>Idea is that even if adversaries obtain old password, they&#39;re no longer useful</li>
<li>But users might have a harder time remembering it</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Password Managers</h3>
<ul>
<li>Automates selecting different password with high entropy for different sights</li>
<li>User must authenticate to this and memorize one strong password</li>
</ul>
<h3>Defense Against Guessing</h3>
<ul>
<li>Guessing attacks are a problem in a small key space<ul>
<li>Adversary has access to common passwords / phrases / common user biases</li>
</ul>
</li>
<li>Data encrypted with solely a password is vulnerable to offline guesses if the attacker doesn&#39;t have to go through a server each time</li>
</ul>
<hr>
<ul>
<li>Strategies:<ul>
<li>Limiting authentic attempts<ul>
<li>Rate-limit login attempts and time-out periods after too many incorrect guesses</li>
<li>Limiting per-user might not be enough because attacker could instead guess &quot;1234&quot; for every username</li>
<li>CAPTCHA can help, but the cost of solving them nowadays is quite low</li>
<li>Most systems have heuristics to rate-limit</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Storing Passwords</h3>
<ul>
<li>Shouldn&#39;t store passwords directly</li>
<li>Rainbow tables are dictionary of hashes of all common passwords<ul>
<li>Can be used to break if you just store hash of password</li>
</ul>
</li>
<li>Hashing with salting can be much more effective</li>
<li>Hash functions should be purposefully expensive / slow (key derivation function) to rate-limit more effectively<ul>
<li>I.e. bcrypt, scrypt, PBKDF2</li>
</ul>
</li>
</ul>
<h3>2FA</h3>
<ul>
<li>Defends against MITM and phishign attacks</li>
<li>Variants<ul>
<li>SMS<ul>
<li>Easy to use / recover</li>
<li>Requires user to trust cell phone network / be in range of cell phone network and still enables phishing attacks</li>
<li>Compromising the server does not leak secrets (just a cell-phone numeber)</li>
</ul>
</li>
<li>TOTP<ul>
<li>Time-based one-time passwords</li>
<li>Server and user device agree on secret value and then generate code based on hash of secret and current time</li>
<li>Server checks if that code is correct by also looking aththe current time</li>
<li>No need for cell phone network anymore, but can be difficult with user setup, changing devices, re-registering secrets if server is compromised</li>
<li>Still allows phishing attacks</li>
</ul>
</li>
<li>Challenge-response (U2F)<ul>
<li>New section</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>U2F</h3>
<ul>
<li>User&#39;s USB dongle has a public/secret key pair<ul>
<li>Server stores public key</li>
<li>To log in, server sends random challenge to user borwser</li>
<li>USB dongle signs this challenge with private key</li>
<li>This can be sent to server for authentication</li>
</ul>
</li>
<li>This disables phishing attacks / compromising server vulnerabilities but is unwieldy for the user</li>
<li>Problem: how does this prevent phishing attacks if attacker visits the site and then forwards this to the user?<ul>
<li>The challenge sent by the server should be tied to the user&#39;s identity</li>
<li>I.e. the nonce could contain a hash of the requestor&#39;s IP / port / hostname</li>
<li>This way, a user could only sign the nonce if they see that it was actually meant for them</li>
<li>If attacker tried to ask server, they would get a nonce with the attacker&#39;s details</li>
<li>Also have the U2F signing protocol sign not just the challenge but instead <code>challenge | server details</code><ul>
<li>I.e. append the challenge to the server hostname / port / etc.</li>
</ul>
</li>
</ul>
</li>
<li>New problem: different servers can see which of their users match up by just comparing the public keys<ul>
<li>Problem since we normally cannot do this with passwords!</li>
<li>Known as cross-site linking</li>
<li>At registration time, device generates new key pair <code>(Kp, Ks)</code></li>
<li>It has a secret <code>Kw</code> that it wraps around <code>Ks</code> and then sends to the site it is registering with</li>
<li>When a site wants to get a login, it sends the wrapped <code>Ks</code> and the <code>Kp</code><ul>
<li>The device can then decrypt <code>Kp</code> and get this working</li>
</ul>
</li>
</ul>
</li>
</ul>
</body></html>