<!DOCTYPE html><html><head>
      <title>temporary</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script
  src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/js/all.min.js"
  crossorigin="anonymous"
></script>
<style>
body {
  font-family: 'Open Sans', sans-serif;
  width: 100%;
  height: 100%;
  top: 0;
  margin: 0;
  padding: 2em calc(max(50% - 457px + 2em, 1em));
  position: relative;
  font-size: 16px;
  line-height: 1.6;
  background-color: #fff;
  overflow: initial;
  box-sizing: border-box;
  word-wrap: break-word;
  color: black;
  background-color: white;
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
}
body > :first-child {
  margin-top: 0;
}
body h1,
body h2,
body h3,
body h4,
body h5,
body h6 {
  color: black;
  padding-bottom: 8px;
  border-bottom: 1px solid black;
  font-weight: 600;
  margin-top: 1em;
  margin-bottom: 16px;
  line-height: 1.2;
}
body h1 {
  font-size: 2.25em;
  padding-bottom: 0.3em;
}
body h2 {
  font-size: 1.75em;
  padding-bottom: 0.3em;
}
body h3 {
  font-size: 1.5em;
}
body h4 {
  font-size: 1.25em;
}
body h5 {
  font-size: 1.1em;
}
body h6 {
  font-size: 1em;
}
body p + ul {
  margin-top: -15px;
}
body a:not([href]) {
  color: inherit;
  text-decoration: none;
}
body a {
  color: #08c;
  text-decoration: none;
}
body a:hover {
  color: #00a3f5;
  text-decoration: none;
}
body > p {
  margin-top: 0;
  margin-bottom: 16px;
  word-wrap: break-word;
}
body > ol,
body > ul {
  margin-bottom: 16px;
}
body ol,
body ul {
  padding-left: 2em;
}
body ol ol,
body ol ul,
body ul ol,
body ul ul {
  margin-top: 0;
  margin-bottom: 0;
}
body li {
  margin-bottom: 0;
}
body li > p {
  margin-top: 0;
  margin-bottom: 0;
}
body code {
  font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
  font-size: 1em;
  padding: 0.15em 0.25em;
  margin: 0;
  white-space: break-spaces;
  background-color: #afb8c133;
  border-radius: 6px;
  color: #000000;
}
body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  color: #1f2328;
  background-color: #e3e6e9;
  border-radius: 6px;
}
body pre > code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}
body hr {
  height: 1px;
  margin: 8px 0;
  background-color: #000000;
  border: 0 none;
}
body table {
  margin: 10px 0 15px 0;
  border-collapse: collapse;
  border-spacing: 0;
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}
body table th {
  font-weight: 700;
  color: #000;
}
body table td,
body table th {
  border: 1px solid #d6d6d6;
  padding: 6px 13px;
}
body dl {
  padding: 0;
}
body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 700;
}
body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}
body ul {
  list-style: disc;
}
body ul ul {
  list-style: circle;
}
body ul ul ul {
  list-style: square;
}
body own-preview ol {
  list-style: decimal;
}
body own-preview ol ol,
body ul ol {
  list-style-type: lower-roman;
}
body own-preview ol ol ol,
body own-preview ol ul ol,
body ul ol ol,
body ul ul ol {
  list-style-type: lower-alpha;
}
body img {
  width: 100%;
  display: block;
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 25px;
}
body .image-caption {
  font-size: 0.8em;
  color: #494949;
  text-align: center;
  margin: -20px auto 10px;
  width: 100%;
}
body .definition {
  border-color: #06c406;
}
body .definition .title {
  background-color: #d9ffd9;
}
body .info {
  border-color: #448aff;
}
body .info .title {
  background-color: #ecf3ff;
}
body .proposition {
  border-color: #448aff;
}
body .proposition .title {
  background-color: #ecf3ff;
}
body .theorem {
  border-color: #448aff;
}
body .theorem .title {
  background-color: #ecf3ff;
}
.admonition {
  border: 1px solid;
  border-radius: 8px;
  margin-bottom: 10px;
}
.admonition .title {
  font-size: 1em;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 8px 8px 0px 0px;
}
.admonition .title svg {
  margin-right: 4px;
}
.admonition .title p {
  margin: 0px;
}
.admonition .body {
  padding: 8px 10px 0px;
}
.admonition .body > :first-child {
  margin-top: 0;
}
.admonition .body > :last-child {
  margin-bottom: 4px;
}
</style>
</head>
<body><h2>Datacenter Networks</h2>
<p><img style="" src="img/datacenter-costs.png"/></p>
<ul>
<li>In most datacenters, 30-50% utilization is considered &quot;good&quot;</li>
<li>Why is it difficult to get efficient server utilization?<ul>
<li>Datacenters have to keep it low utilization to keep enough compute in reserve for spikes in utilization</li>
<li>Also has for fault tolerance</li>
<li>Uneven application fit<ul>
<li>Each server has CPU / memory / disk and most applications exhaust one resource and not the others</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Role of the Network</strong>:</p>
<ul>
<li>Enable high server utilization by getting servers across the datacenter to be able to communicate effectively with one another</li>
<li>Turn the servers into a single large fungible pool of resources</li>
<li>Don&#39;t make the developer think about where their application is<ul>
<li>Provide the illusion of &quot;one big switch&quot; no matter where the servers are in the datacenter</li>
<li>We&#39;ll have to implement it with smaller switches</li>
</ul>
</li>
<li>When measuring latency, we not only care about average latency but also tail latency<ul>
<li>I.e. 99.9th percentile latency (three 9s)</li>
</ul>
</li>
</ul>
<h3>Tree Topology</h3>
<p><img style="" src="img/dc-tree-top.png"/></p>
<ul>
<li>We have redundancy to provide failure resiliency (so there are multiple ways to communicate with a server)</li>
<li>We run into a problem of imbalanced uplinks vs downlinks<ul>
<li>Say five servers want to communicate with another server (i.e. some controller)</li>
<li>Then, the switch above the server is getting 4 incoming and only 1 outgoing, which causes inefficiencies because of the imbalance</li>
<li>As we get higher up in the tree, we could get something like 200:1 imbalance</li>
</ul>
</li>
<li>If these tree networks are statically provisioned:<ul>
<li>This was common back in the early days</li>
<li>Then if half of your serverse aren&#39;t doing work, then there&#39;s an efficiency issue</li>
</ul>
</li>
<li>How do we get a more dynamic allocation?<ul>
<li>Decouple ip address from location</li>
<li>Before, we had a specific chunk of the datacenter be this IP address</li>
<li>Adding new servers would require you to update a bunch of routers&#39; routing tables</li>
<li>Instead, we will virtualize everything<ul>
<li>We will have our own layer over IP addresses to not treat them as physical locations but as just names</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Virtual Layer 2 (VL2) Switch</h2>
<p><strong>Goals</strong>:</p>
<ul>
<li>Uniform high capacity<ul>
<li>Maximum rate of server-to-server traffic flow should only be limited by capacity on NICs</li>
<li>Assinging servers to service should be independent of network topology</li>
</ul>
</li>
<li>Performance isolation<ul>
<li>Traffic of one service should not affect others</li>
</ul>
</li>
<li>Routing / addressing<ul>
<li>Easily assign any server to any service</li>
<li>VM keeps the same IP address even after migration</li>
</ul>
</li>
</ul>
<p><strong>Key Ideas</strong>:</p>
<ul>
<li>Use Clos topology to connect servers</li>
<li>Valiant load balancing to provide high bisection bandwidth across multiple paths</li>
<li>Name / location separation</li>
</ul>
<p><strong>Graphs</strong>:</p>
<p><img style="" src="img/flow-distribution-analysis.png"/></p>
<ul>
<li>There are a ton of small flows</li>
<li>But most bytes are part of a very large flow</li>
<li>We&#39;ll see later ML workflows are not like this</li>
</ul>
<p><img style="" src="img/concurrent-connections.png"/></p>
<p><strong>Traffic Matrix Analysis</strong></p>
<ul>
<li>Can we predict based on the past the amount of traffic between two servers?<ul>
<li>Hard to do this because we wanted to isolate the applications from the servers they are running on</li>
<li>The pattern changes nearly constantly with no periodicity and a lot of randomness</li>
</ul>
</li>
</ul>
<h3>Clos Topology</h3>
<ul>
<li>Use a huge number of paths</li>
<li>We organize switches in two layers</li>
<li>A bunch of servers are all connected to some leaf switch (aggregation router)<ul>
<li>The layer above the leaf switch is called the spine</li>
<li>The spine and leaf form a fully connected network</li>
</ul>
</li>
<li>We create so many paths between two layers that we can create non-blocking performance</li>
<li>Emulates just having a big switch</li>
</ul>
<p><img style="" src="img/spine-leaf-clos.png"/></p>
<p><img style="" src="img/2024-10-12-17-53-22.png"/></p>
<h3>Routing</h3>
<ul>
<li>We have a lot of redundancy in routing</li>
<li>We want to load balance</li>
<li>We can&#39;t just use what is on the Internet<ul>
<li>This won&#39;t load balance</li>
<li>We would have to send tons and tons of routing entries / messages, but this doesn&#39;t scale well when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> is going to the millions</li>
</ul>
</li>
<li>We want something cheap and simple that we can deploy at scale<ul>
<li>We can just use randomness to distribute among all paths that ahve the same cost</li>
</ul>
</li>
<li>How do we decide when to keep a flow on the same route?<ul>
<li>I.e. there are some flows sensitive to reordering that we might want to stay on the same path</li>
<li>If you have TCP, you should keep that flow entirely on the same path rather than split up the packets</li>
<li>With this, we can hash a 5-tuple of the packet header information and then modulo it by number of equal cost paths to get which path to send it along</li>
</ul>
</li>
<li>This does lead to suboptimal balancing<ul>
<li>Elephant (super large) flows are a problem and also hash collisions</li>
</ul>
</li>
<li>Are hash collisions a problem?<ul>
<li>We can set up our network so that the uplinks of our switches are a lot higher capacity than our downlinks<br><img style="" src="img/uplink-downlink-diff.png"/></li>
<li>Intuition for why this mitigates hash collision problem:<ul>
<li>Imagine we have 20 bins each with size 1 and we throw 10 balls in</li>
<li>Or we have 2 bins each with size 10 and we throw 10 balls in</li>
<li>What is probability of staying within capacity?<ul>
<li>First: 3.27%</li>
<li>Second: 99.95%</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</body></html>