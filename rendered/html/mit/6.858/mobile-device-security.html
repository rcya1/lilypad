<!DOCTYPE html><html><head>
      <title>mobile-device-security</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script
  src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/js/all.min.js"
  crossorigin="anonymous"
></script>
<style>
body {
  font-family: 'Open Sans', sans-serif;
  width: 100%;
  height: 100%;
  top: 0;
  margin: 0;
  padding: 2em calc(max(50% - 457px + 2em, 1em));
  position: relative;
  font-size: 16px;
  line-height: 1.6;
  background-color: #fff;
  overflow: initial;
  box-sizing: border-box;
  word-wrap: break-word;
  color: black;
  background-color: white;
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
}
body > :first-child {
  margin-top: 0;
}
body h1,
body h2,
body h3,
body h4,
body h5,
body h6 {
  color: black;
  padding-bottom: 8px;
  border-bottom: 1px solid black;
  font-weight: 600;
  margin-top: 1em;
  margin-bottom: 16px;
  line-height: 1.2;
}
body h1 {
  font-size: 2.25em;
  padding-bottom: 0.3em;
}
body h2 {
  font-size: 1.75em;
  padding-bottom: 0.3em;
}
body h3 {
  font-size: 1.5em;
}
body h4 {
  font-size: 1.25em;
}
body h5 {
  font-size: 1.1em;
}
body h6 {
  font-size: 1em;
}
body p + ul {
  margin-top: -15px;
}
body a:not([href]) {
  color: inherit;
  text-decoration: none;
}
body a {
  color: #08c;
  text-decoration: none;
}
body a:hover {
  color: #00a3f5;
  text-decoration: none;
}
body > p {
  margin-top: 0;
  margin-bottom: 16px;
  word-wrap: break-word;
}
body > ol,
body > ul {
  margin-bottom: 16px;
}
body ol,
body ul {
  padding-left: 2em;
}
body ol ol,
body ol ul,
body ul ol,
body ul ul {
  margin-top: 0;
  margin-bottom: 0;
}
body li {
  margin-bottom: 0;
}
body li > p {
  margin-top: 0;
  margin-bottom: 0;
}
body code {
  font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
  font-size: 1em;
  padding: 0.15em 0.25em;
  margin: 0;
  white-space: break-spaces;
  background-color: #afb8c133;
  border-radius: 6px;
  color: #000000;
}
body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  color: #1f2328;
  background-color: #e3e6e9;
  border-radius: 6px;
}
body pre > code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}
body hr {
  height: 1px;
  margin: 8px 0;
  background-color: #000000;
  border: 0 none;
}
body table {
  margin: 10px 0 15px 0;
  border-collapse: collapse;
  border-spacing: 0;
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}
body table th {
  font-weight: 700;
  color: #000;
}
body table td,
body table th {
  border: 1px solid #d6d6d6;
  padding: 6px 13px;
}
body dl {
  padding: 0;
}
body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 700;
}
body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}
body ul {
  list-style: disc;
}
body ul ul {
  list-style: circle;
}
body ul ul ul {
  list-style: square;
}
body own-preview ol {
  list-style: decimal;
}
body own-preview ol ol,
body ul ol {
  list-style-type: lower-roman;
}
body own-preview ol ol ol,
body own-preview ol ul ol,
body ul ol ol,
body ul ul ol {
  list-style-type: lower-alpha;
}
body img {
  width: 100%;
  display: block;
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 25px;
}
body .image-caption {
  font-size: 0.8em;
  color: #494949;
  text-align: center;
  margin: -20px auto 10px;
  width: 100%;
}
body .definition {
  border-color: #06c406;
}
body .definition .title {
  background-color: #d9ffd9;
}
body .info {
  border-color: #448aff;
}
body .info .title {
  background-color: #ecf3ff;
}
body .proposition {
  border-color: #448aff;
}
body .proposition .title {
  background-color: #ecf3ff;
}
body .theorem {
  border-color: #448aff;
}
body .theorem .title {
  background-color: #ecf3ff;
}
.admonition {
  border: 1px solid;
  border-radius: 8px;
  margin-bottom: 10px;
}
.admonition .title {
  font-size: 1em;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 8px 8px 0px 0px;
}
.admonition .title svg {
  margin-right: 4px;
}
.admonition .title p {
  margin: 0px;
}
.admonition .body {
  padding: 8px 10px 0px;
}
.admonition .body > :first-child {
  margin-top: 0;
}
.admonition .body > :last-child {
  margin-bottom: 4px;
}
</style>
</head>
<body><h2>Mobile Device Security</h2>
<ul>
<li>Design assumes:<ul>
<li>Someone steals your iPhone</li>
<li>Device is passcode-protected and locked at time of theft</li>
</ul>
</li>
<li>Potential attacks:<ul>
<li>Exhaustive search for passcode</li>
<li>Impersonate fingerprint / face</li>
<li>Take apart phones and remove flash storage / read from RAM</li>
<li>Exploit a bug in the OS kernel<ul>
<li>USB / WiFi / radio might have bugs to exploit</li>
</ul>
</li>
<li>Install a hacked version of the OS w/o security checks<ul>
<li>I.e. redirect network traffic to use adversary&#39;s update server</li>
<li>Take apart phone and write different OS to flash chip</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>iOS Hardware Architecture</h3>
<ul>
<li>Components<ul>
<li>Main CPU</li>
<li>DRAM</li>
<li>Flash file storage</li>
<li>AES encryption engine between main CPU / DRAM and flash storage</li>
<li>Secure enclave CPU<ul>
<li>UID cryptographic key in enclave hardware</li>
<li>We can use this to decrypt / encrypt but we cannot get this back out</li>
</ul>
</li>
<li>Authentication sensors: fingerprint reader / face ID camera</li>
</ul>
</li>
</ul>
<h3>Secure Boot</h3>
<ul>
<li>Goal: make sure adversary cannot run modified OS / apps / enclave</li>
<li>At power on, CPU starts executing from boot ROM that is read-only</li>
<li>Boot sequence: boot ROM -&gt; iBoot -&gt; OS kernel -&gt; apps<ul>
<li>Boot ROM: checks iBoot code is signed by Apple&#39;s secret key<ul>
<li>Checks it using Apple&#39;s public key</li>
</ul>
</li>
<li>iBoot: checks OS kernel code is signed by Apple</li>
<li>OS kernel: checks apps are signed by developer</li>
</ul>
</li>
<li>How to check things are signed:<ul>
<li>Apple holds some private key only known to them and code is signed<ul>
<li>Code is hashed</li>
<li>This hash is then encrypted with Apple&#39;s private key</li>
</ul>
</li>
<li>This hash is then decrypted using the public key stored in the secure enclave, then hash of the entire code has to match this decrypteed hash</li>
</ul>
</li>
</ul>
<h3>Downgrade Attacks</h3>
<ul>
<li>Downgrade attacks:<ul>
<li>Replace OS kernel with an older one with a known bug</li>
<li>Bad solution:<ul>
<li>iBoot checks OS kernel version is at least a certain version</li>
<li>Adversary could modify the stored version number</li>
</ul>
</li>
<li>Good solution:<ul>
<li>Each device has a unique ID called the ECID</li>
<li>Apple update servers signs each upgrade with a specific ECID</li>
<li>Boot sequence checks signature is for this phone&#39;s ECID</li>
<li>Good because:<ul>
<li>Apple update servers will not sign an out-of-date kernel</li>
<li>Adversary unlikely to have old software with victim&#39;s exact ECID</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Secure Enclave</h3>
<ul>
<li>Purpose: prevent main CPU from ever seeing crypto keys<ul>
<li>Also defend against passcode guessing</li>
</ul>
</li>
<li>CPU asks enclave to do things i.e. help decrypt certain things<ul>
<li>Enclave is a separate CPU with a secure boot sequence</li>
</ul>
</li>
<li>Shares DRAM with the main CPU<ul>
<li>Encrypts its own memory contents</li>
</ul>
</li>
<li>Runs fixed Apple software</li>
</ul>
<hr>
<ul>
<li>Overall plan: all user data is encrypted<ul>
<li>Allow decryption only phone is unlocked</li>
</ul>
</li>
<li>Offloaded to separate CPU to prevent compromised OS kernel from getting decryption keys / fingerprint / face data or bypassing passcode retry limits<ul>
<li>Allows hiding of keys with memory encryption / auth so direct read of RAM doesn&#39;t reveal keys</li>
<li>The main CPU cannot have all memory encrypted, but secure enclave is fine</li>
</ul>
</li>
<li>The decryption keys are computed based on passcode<ul>
<li>More on this later, what ends up happening is only three or so keys are computed based on this and are used to wrap other keys</li>
<li>This is cached<ul>
<li>Fingerprint / face recognition data can be used to retrieve cached value</li>
</ul>
</li>
<li>We avoid having the OS communicate the sensor data directly to the secure enclave<ul>
<li>Instead the sensor data is encrypted with manufacturing time secret key that the secure enclave knows</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Data Encryption</h3>
<ul>
<li>Files are encrypted in flash storage</li>
<li>They generate data encryption keys based on the passcode rather than storing it permanently<ul>
<li>This way they exist nowhere on device after reboot and can be forgotten when device locks</li>
<li>The encryption key is based on both the UID (hardware) of the secure enclave and the password</li>
</ul>
</li>
<li>The key is generated slowly to limit speed of exhaustive search, and enclave can also limit attempts<ul>
<li>Dependent on UID to avoid brute forcing outside of the device</li>
</ul>
</li>
<li>Background apps:<ul>
<li>When the phone is locked, some apps have to be able to run and read/write files</li>
<li>OS kernel can generate a secret key for each of these apps and then &quot;wrap&quot; the key with it for just this file and give it</li>
<li>The original actual key is no longer actually stored and only this app should be able to figure out what the actual key they need is</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>The entire filesystem metadata is encrypted with a key that is based on the UID so that even if you take this flash chip out and put it in a different phone, it cannot read<ul>
<li>This is given out to the OS once the phone boots</li>
</ul>
</li>
<li>Each separate file is encrypted with a different key, which is then wrapped by another key called the kdf before being sent back to the OS<ul>
<li>Are stored in the secure enclave only</li>
<li>These keys can then be allocated out to different parts of the OS for different protection levels that are based on when the OS deletes the keys from its memory<ul>
<li>Complete: can decrypt only when phone is currently unlocked<ul>
<li>Derived from passcode on unlock, discarded when locked</li>
</ul>
</li>
<li>Complete unless open: file can be written at any time but not read, used specifically for downloading attachments</li>
<li>Until first authentication<ul>
<li>When phone was unlocked for the first time, this is derived</li>
<li>Discarded only on power-off</li>
<li>Default for third-party app data</li>
</ul>
</li>
<li>No protection: can decrypt any time: only derived from UID and not passcode</li>
</ul>
</li>
<li>After the OS deletes the key, it will have to go back to the secured enclave with the password and re-ask for the key, which will require the password</li>
</ul>
</li>
<li>To use these wrapped file keys:<ul>
<li>FS code on CPU asks secure enclave to get certain keys for certain files</li>
<li>CPU never receives raw keys, but instead wrapped ones</li>
<li>The secure enclave and the AES engine (between the CPU and its flash memory) share a secret<ul>
<li>The CPU then has to send this to the AES engine to &quot;program&quot; it, so the CPU still never sees the actual key</li>
</ul>
</li>
</ul>
</li>
<li>This allows you to change the pin fast:<ul>
<li>You just need to recompute these kdf keys (only 3-4) and then you&#39;re good because the actual file keys don&#39;t have to change</li>
<li>Secure enclave will then just have to start encrypting the filesystem keys with new stuff</li>
</ul>
</li>
</ul>
</body></html>