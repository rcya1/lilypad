<!DOCTYPE html><html><head>
      <title>temporary</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script
  src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/js/all.min.js"
  crossorigin="anonymous"
></script>
<style>
body {
  font-family: 'Open Sans', sans-serif;
  width: 100%;
  height: 100%;
  top: 0;
  margin: 0;
  padding: 2em calc(max(50% - 457px + 2em, 1em));
  position: relative;
  font-size: 16px;
  line-height: 1.6;
  background-color: #fff;
  overflow: initial;
  box-sizing: border-box;
  word-wrap: break-word;
  color: black;
  background-color: white;
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
}
body > :first-child {
  margin-top: 0;
}
body h1,
body h2,
body h3,
body h4,
body h5,
body h6 {
  color: black;
  padding-bottom: 8px;
  border-bottom: 1px solid black;
  font-weight: 600;
  margin-top: 1em;
  margin-bottom: 16px;
  line-height: 1.2;
}
body h1 {
  font-size: 2.25em;
  padding-bottom: 0.3em;
}
body h2 {
  font-size: 1.75em;
  padding-bottom: 0.3em;
}
body h3 {
  font-size: 1.5em;
}
body h4 {
  font-size: 1.25em;
}
body h5 {
  font-size: 1.1em;
}
body h6 {
  font-size: 1em;
}
body p + ul {
  margin-top: -15px;
}
body a:not([href]) {
  color: inherit;
  text-decoration: none;
}
body a {
  color: #08c;
  text-decoration: none;
}
body a:hover {
  color: #00a3f5;
  text-decoration: none;
}
body > p {
  margin-top: 0;
  margin-bottom: 16px;
  word-wrap: break-word;
}
body > ol,
body > ul {
  margin-bottom: 16px;
}
body ol,
body ul {
  padding-left: 2em;
}
body ol ol,
body ol ul,
body ul ol,
body ul ul {
  margin-top: 0;
  margin-bottom: 0;
}
body li {
  margin-bottom: 0;
}
body li > p {
  margin-top: 0;
  margin-bottom: 0;
}
body code {
  font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
  font-size: 1em;
  padding: 0.15em 0.25em;
  margin: 0;
  white-space: break-spaces;
  background-color: #afb8c133;
  border-radius: 6px;
  color: #000000;
}
body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  color: #1f2328;
  background-color: #e3e6e9;
  border-radius: 6px;
}
body pre > code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}
body hr {
  height: 1px;
  margin: 8px 0;
  background-color: #000000;
  border: 0 none;
}
body table {
  margin: 10px 0 15px 0;
  border-collapse: collapse;
  border-spacing: 0;
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}
body table th {
  font-weight: 700;
  color: #000;
}
body table td,
body table th {
  border: 1px solid #d6d6d6;
  padding: 6px 13px;
}
body dl {
  padding: 0;
}
body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 700;
}
body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}
body ul {
  list-style: disc;
}
body ul ul {
  list-style: circle;
}
body ul ul ul {
  list-style: square;
}
body own-preview ol {
  list-style: decimal;
}
body own-preview ol ol,
body ul ol {
  list-style-type: lower-roman;
}
body own-preview ol ol ol,
body own-preview ol ul ol,
body ul ol ol,
body ul ul ol {
  list-style-type: lower-alpha;
}
body img {
  width: 100%;
  display: block;
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 25px;
}
body .image-caption {
  font-size: 0.8em;
  color: #494949;
  text-align: center;
  margin: -20px auto 10px;
  width: 100%;
}
body .definition {
  border-color: #06c406;
}
body .definition .title {
  background-color: #d9ffd9;
}
body .info {
  border-color: #448aff;
}
body .info .title {
  background-color: #ecf3ff;
}
body .proposition {
  border-color: #448aff;
}
body .proposition .title {
  background-color: #ecf3ff;
}
.admonition {
  border: 1px solid;
  border-radius: 8px;
  margin-bottom: 10px;
}
.admonition .title {
  font-size: 1.125em;
  font-weight: 600;
  padding: 4px 10px;
  border-radius: 8px 8px 0px 0px;
}
.admonition .title svg {
  margin-right: 4px;
}
.admonition .title p {
  margin: 0px;
}
.admonition .body {
  padding: 8px 10px 0px;
}
.admonition .body > :first-child {
  margin-top: 0;
}
.admonition .body > :last-child {
  margin-bottom: 4px;
}
</style>
</head>
<body><h2>Network Security</h2>
<ul>
<li>A big open network invites many attacks<ul>
<li>Authentication / confidentiality</li>
<li>Liveness (uptime of services)</li>
<li>Privacy</li>
</ul>
</li>
<li>Today: attacks on core network protocols</li>
</ul>
<hr>
<ul>
<li>Internet core:<ul>
<li>Open network consisting of many ISPs</li>
<li>Peering agreements between ISPs provide connectivity</li>
<li>Many protocols:<ul>
<li>TCP, BGP, DHCP, UDP, telnet, FTP, IMAP</li>
<li>Defined by RFC interfaces</li>
<li>Many implementations of these</li>
<li>Changing the protocol is much harder than changing implementation</li>
</ul>
</li>
</ul>
</li>
<li>There are now many secure higher layers such as:<ul>
<li>Kerberos, SSH, SSL</li>
<li>Enabled by the advent of cryptographyj</li>
</ul>
</li>
<li>Core network still lacks security<ul>
<li>Mostly concerned with liveness</li>
<li>Hosts manage end-to-end security instead of the actual network</li>
<li>This design is successful, but important to look at attacks</li>
</ul>
</li>
</ul>
<h2>Forging IP Addresses</h2>
<h3>Remote Login</h3>
<ul>
<li>Example internet application: remote login (1980)</li>
<li>Uses telnet to open a TCP connection to the login program</li>
<li>Attacker can:<ul>
<li>Steal the password by snooping on network</li>
<li>Modify data in flight</li>
<li>Inject false data</li>
<li>Re-direct conversation with routing</li>
</ul>
</li>
<li>rlogin deals with this by not using a password to authenticate<ul>
<li>Destination only allows hosts in its hostfile to log in</li>
<li>Attacker could pose as the client&#39;s IP address</li>
<li>But TCP communication is both ways, so if the attacker lies about the source, then the server&#39;s replies will not go back to the attacker</li>
</ul>
</li>
</ul>
<h3>TCP Setup</h3>
<ul>
<li>On initial handshake, the client sends a sync request to the server with its sequence numbers</li>
<li>Server responds with its sequence numbers and an acknowledgement of the client sequence numbers<ul>
<li>Ack is important so the client knows that this is coming from the real server</li>
<li>The client only has a guarantee that its destination packet reached the correct server<ul>
<li>Does not have guarantee that its receiving messages from the real server</li>
</ul>
</li>
<li>Client sends back an acknowledgement of the server&#39;s sequence numbers and the data it wants to send</li>
</ul>
</li>
</ul>
<h3>TCP Sequence Number Attack</h3>
<ul>
<li>Adversary wants to simulate a connection to the server by a client C</li>
<li>Attacker sends a TCP packet with src = C</li>
<li>Server will send sequence numbers to C</li>
<li>Attacker has to guess the sequence numbers sent to C to be able to communicate with the server<ul>
<li>Could try guessing based on guessing how the server does sequence number management</li>
<li>Attacker could do an actual connection to the server to learn about what kinds of sequence numbers the server is currently using and then guess the next one</li>
</ul>
</li>
<li>The real client will receive the actual packet and might think that it is an old packet<ul>
<li>Real client might send an abort packet to shut down this connection</li>
<li>The attacker might have to race to get there before the RST arrives</li>
</ul>
</li>
<li>Security risks:<ul>
<li>If authentication is based on IP address, SN attacker can pretend to be a host in the trusted user list<ul>
<li>Breaks rlogin; key problem was assuming that the TCP layer&#39;s sender field was legit</li>
<li>IP authentication is no longer used for remote login</li>
</ul>
</li>
<li>Denial of service attack:<ul>
<li>Can constantly send reset packets</li>
<li>Servers actually accept reset packets for a large window of sequence numbers so you don&#39;t even need to get the sequence number exactly right<ul>
<li>You can just guess</li>
</ul>
</li>
<li>These can be used to target TCP connections between BGP routers<ul>
<li>Causes routers to assume link failure and affect traffic</li>
</ul>
</li>
</ul>
</li>
<li>Hijack existing connections<ul>
<li>Can inject data into an existing connection</li>
<li>Wait for someone to log in and then hijack</li>
</ul>
</li>
</ul>
</li>
<li>Mitigation:<ul>
<li>End to end encryption (i.e. SSL as used in the next lecture)</li>
<li>ISPs can filter packets with obviously forged IP source addresses<ul>
<li>Hard for complex networks</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Hardening TCP against forged IP source addresses</h3>
<ul>
<li>Need to make it harder for attacker to guess next ISN (initial sequence number)</li>
<li>Can&#39;t choose them completely randomly or else you violate TCP speec<ul>
<li>Need to avoid recently used sequence numbers for same host / port pair</li>
</ul>
</li>
<li>Can&#39;t do random increments because we don&#39;t want to wrap around very often<ul>
<li>Need to keep these increments small</li>
</ul>
</li>
<li>Have to be careful about how we generate random numbers since random number generators can be reverse-engineered</li>
<li>Main idea that is implemented in most OS is to use a random offset for each src/dest pair<ul>
<li>ISN = ISN_old + SHA1(srcip, srcport, dstip, dstport, secret)</li>
</ul>
</li>
<li>Whole idea is to prevent attacker from being able to make an ordinary connection and using that info to try to guess the ISN for another client</li>
</ul>
<h2>Liveness</h2>
<h3>SYN Attacks</h3>
<ul>
<li>SYN flooding: first high-profile DoS attack<ul>
<li>SYN = synchronization request (initial packet)</li>
<li>Server must check client&#39;s ACKs to it sending back sequence number<ul>
<li>The original implementation of TCP kept the states for these &quot;half-open&quot; connections</li>
<li>Kept it for minutes if client is slow / network lossy</li>
<li>Only willing to remember 50 half-open connections to avoid OOM</li>
<li>Silently ignored new connections if it already had 50 waiting</li>
</ul>
</li>
<li>Attack sends SYN packet with forged random IP addresses<ul>
<li>Most of these will never respond and the server just waits for them to send a third packet when they never will</li>
<li>Server begins to ignore legitimate connection requests</li>
<li>Don&#39;t even need to send these that fast because servers keep half-open connections for minutes</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Mitigation: SYN cookies<ul>
<li>Make the server stateless until it receives the third packet</li>
<li>Tricky because the half open-state was what helped ensure source IP wasn&#39;t forged by checking the packet had the right ACK</li>
<li>Use a bit of cryptography<ul>
<li>Encode server-side state into sequence number<ul>
<li>ISN = SN_c + timestamp || SHA1(src/dest addr/port, secret, timestamp)</li>
<li>Timestamp is coarse-grained (minutes) to ensure that clients have enough time to submit back a packet</li>
<li>ISNs are per client so attacker can&#39;t guess for a forged IP address</li>
<li>Upon receiving the third packet, the server just has to recompute to see if this is a feasible packet which should have only been known by the client that receives it legitimately</li>
</ul>
</li>
</ul>
</li>
<li>Successfully blunted low-rate SYN-flooding DoS attacks</li>
</ul>
</li>
</ul>
<h3>Bandwidth Amplification</h3>
<ul>
<li>Attacker&#39;s goal is to overwhelm server / link so legit traffic is discarded</li>
<li>Send ICMP echo request (ping) packets to broadcast address of a network<ul>
<li>Used to be that you would get an ICMP echo reply from all machines on network</li>
<li>If you fake a packet with a victim&#39;s address, then the victim gets all replies</li>
<li>If you find a subnet with 100 machines on a fast network, then you get 100x amplification on your attack</li>
</ul>
</li>
<li>Fixed by routers blocking directed broadcast (packets sent tobroadcast address)</li>
</ul>
<hr>
<ul>
<li>Modern variant:<ul>
<li>Use DNS because with a small query, a server might send back a large respones<ul>
<li>DNSSEC makes this even worse since it contains lots of signatures</li>
<li>DNS runs over UDP so source address is completely unverified</li>
</ul>
</li>
<li>Hard to fix this because DNS has to respond to anyone</li>
</ul>
</li>
<li>Generally, can be mitigated via a DoS protection service (i.e. Akamai)<ul>
<li>These have lots of available bandwidth and you tunnel requests into them first</li>
<li>They can filter out DoS attack traffic (i.e. DNS amplification responses)</li>
</ul>
</li>
</ul>
<h2>Routing Protocol Attacks</h2>
<ul>
<li>Generally, routing protocols are overly-trusting of participants</li>
<li>ARP: within a single Ethernet network sending via MAC addresses of routers<ul>
<li>To send an IP packet, you just need the MAC address</li>
<li>In this protocol, you broadcast a request for target&#39;s mac and anyone can listen to / send a reply with no authentication</li>
<li>You can just impersonate people</li>
</ul>
</li>
<li>DHCP: within a single Ethernet network sending via IP address<ul>
<li>Client asks for IP address by sending a broadcast request</li>
<li>DHCP server responds with no auth</li>
<li>Adversary can imeprsonate DHCP server to new clients on the network</li>
</ul>
</li>
<li>BGP: Internet-wide<ul>
<li>Huge routing system</li>
<li>Any BGP participant router can announce route to any IP address</li>
<li>You can announce you have a path to MIT and people will route through you<ul>
<li>You can inspect / modify traffic and then forward to MIT</li>
</ul>
</li>
<li>Fixes:<ul>
<li>Trusted database of who is allowed to announce what IP prefixes</li>
<li>This database is a weak point</li>
</ul>
</li>
</ul>
</li>
<li>The open Internet makes it easy for attackers to gather useful info<ul>
<li>Can probe random hosts to see if they are running vulnerable software / protocols</li>
<li>Can scan entire Internet (2^32 addresses) in just 45 minutes</li>
</ul>
</li>
</ul>
<h2>Improving Security</h2>
<ul>
<li>Firewalls: partial fix but widely used<ul>
<li>Issue if adversary is within firewalled network</li>
<li>Hard to determine if packet is malicious</li>
<li>Hard to authenticate src / dst fields</li>
</ul>
</li>
<li>Cryptographic security on top of TCP / IP can be used but is hard</li>
</ul>
</body></html>